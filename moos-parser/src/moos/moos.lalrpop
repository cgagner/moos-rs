use std::str::FromStr;
use crate::lexers::{Location, TokenRange};
use crate::moos::error::MoosParseError;
use crate::moos::lexer::{State, Token};
use crate::moos::tree::{self, Line};
use lalrpop_util::ErrorRecovery;

//grammar<'input>(input: &'input str);
grammar<'s, 'input>(state: &'s mut State<'input>, input: &'input str);

pub Lines: tree::Lines<'input> = {
    <Line*> => <>.into()
}

pub Line: Line<'input> = {
    "EOL" => Line::EndOfLine,
    <l:@L> <comment:Comment> <r:@R> "EOL" => Line::Comment{comment, line: l.line},
    <l:@L> <assignment:Assignment> => Line::Assignment{assignment, line: l.line},
    Define => <>,
    ProcessConfig => <>,
    <l:@L> <variable:Variable> "EOL" => Line::Variable{variable, line: l.line},
    <l:@L> <error:!> <r:@R> => {
        match &error.error {
            lalrpop_util::ParseError::UnrecognizedEOF { location, expected } => {
                if expected.contains(&"\"#endif\"".to_string()) {
                    let endl = if l.line < r.line {
                        Location::new(l.line + 1, 0)
                    } else {
                        r
                    };
                    let new_error = lalrpop_util::ErrorRecovery { 
                        error: lalrpop_util::ParseError::User {
                            error: MoosParseError::new_missing_endif(l, endl)
                        },
                        dropped_tokens: vec![]
                    };
                    state.errors.push(new_error);
                }
            }
            _ => {}
        }
        state.errors.push(error); 
        Line::Error(l.line, r.line)
    },
}

Variable: tree::Variable<'input> = {
    <l:@L> <text:"EnvVariable"> <r:@R> => tree::Variable::Regular{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `EnvVariable`")},
    <l:@L> <text:"PartialEnvVariable"> <r:@R> => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: MoosParseError::new_missing_trailing('}', l, r)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        tree::Variable::Partial{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `PartialEnvVariable`")}
    },
}

Value: tree::Value<'input> = {
    <l:@L> <value:"bool"> <r:@R> => tree::Value::Boolean(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"int"> <r:@R> => tree::Value::Integer(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"float"> <r:@R> => tree::Value::Float(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"ValueString"> <r:@R> => tree::Value::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <quote: Quote> => quote.into(),
    <value: Variable> => value.into(),
}

VariableString: tree::VariableString<'input> = {
    <l:@L> <value:"ValueString"> <r:@R> => tree::VariableString::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    Variable => tree::VariableString::Variable(<>),
}

VariableStrings: tree::VariableStrings<'input> = {
    <variables: VariableString+> => variables.into()
}

Quote: tree::Quote<'input> = {
    <l:@L> QuoteBegin <content: Value*> QuoteEnd <r:@R> => tree::Quote{content: content.into(), range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Quote`")}
}

Comment: tree::Comment<'input> = {
    <l:@L> <text:"Comment"> <r:@R> => tree::Comment{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Comment`")},
}

Assignment: tree::Assignment<'input> = {
    <name:VariableStrings> "=" <value:Value*> <comment: Comment?> "EOL" => tree::Assignment{name, value: value.into(), comment},
}

Define: Line<'input> = {
    <l:@L> "define:" <r:@R> <assignment: Assignment> => Line::Define{assignment, line: l.line, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `define:`")},
}

ProcessConfigLine: Line<'input> = {
    "EOL" => Line::EndOfLine,
    <l:@L> <comment:Comment> <r:@R> "EOL" => Line::Comment{comment, line: l.line},
    <l:@L> <assignment:Assignment> => Line::Assignment{assignment, line: l.line},
    Define => <>,
    <l:@L> <variable:Variable> "EOL" => Line::Variable{variable, line: l.line},
    <l:@L> <error:!> <r:@R> => {
        match &error.error {
            lalrpop_util::ParseError::UnrecognizedEOF { location, expected } => {
                if expected.contains(&"\"#endif\"".to_string()) {
                    let endl = if l.line < r.line {
                        Location::new(l.line + 1, 0)
                    } else {
                        r
                    };
                    let new_error = lalrpop_util::ErrorRecovery { 
                        error: lalrpop_util::ParseError::User {
                            error: MoosParseError::new_missing_endif(l, endl)
                        },
                        dropped_tokens: vec![]
                    };
                    state.errors.push(new_error);
                }
            }
            _ => {}
        }
        state.errors.push(error); 
        Line::Error(l.line, r.line)
    },
}

ProcessConfig: Line<'input> = {
    <pl:@L> "ProcessConfig" <pr:@R> "=" <process_name: VariableStrings> <process_config_comment: Comment?> "EOL" 
    <ocl:@L> "{" <open_curly_comment: Comment?> "EOL"
    <body: ProcessConfigLine*>
    <ccl:@L> "}" <close_curly_comment: Comment?> "EOL"
        => Line::ProcessConfig { 
            process_config: tree::ProcessConfig{
                process_config_comment,
                process_name,
                open_curly_line: ocl.line,
                open_curly_index: ocl.index,
                open_curly_comment,
                close_curly_line: ccl.line,
                close_curly_index: ccl.index,
                close_curly_comment,
                body: body.into(),
            },
            line: pl.line,
            range: TokenRange::new_line(pl,pr).expect("Invalid token range while parsing `ProcessConfig`")  
        },
}


// ---------------------------------------------------------------------------
// Token Definitions 
// ---------------------------------------------------------------------------

extern {  
    type Location = crate::lexers::Location;
    type Error = MoosParseError<'input>;
    
    enum Token<'input> {
        "Comment" => Token::Comment(<&'input str>),
        QuoteBegin => Token::QuoteBegin,
        QuoteEnd => Token::QuoteEnd,
        "ValueString" => Token::ValueString(<&'input str>),
        "EOL" => Token::EOL,
        "EnvVariable" => Token::EnvVariable(<&'input str>),
        "PartialEnvVariable" => Token::PartialEnvVariable(<&'input str>),
        "int" => Token::Integer(<i64>, <&'input str>),
        "float" => Token::Float(<f64>, <&'input str>),
        "bool" => Token::Boolean(<bool>, <&'input str>),
        "=" => Token::AssignmentOp,
        "define:" => Token::DefineKeyword,
        "ProcessConfig" => Token::ProcessConfigKeyword,
        "{" => Token::CurlyOpen,
        "}" => Token::CurlyClose,
    }
}
