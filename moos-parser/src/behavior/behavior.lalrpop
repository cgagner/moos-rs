use std::str::FromStr;
use crate::lexers::{Location, TokenRange};
use crate::behavior::error::BehaviorParseError;
use crate::behavior::lexer::{State, Token};
use crate::behavior::tree::{self, Line};
use lalrpop_util::ErrorRecovery;

//grammar<'input>(input: &'input str);
grammar<'s, 'input>(state: &'s mut State<'input>, input: &'input str);

pub Lines: tree::Lines = {
    <Line*> => <>.into()
}

pub Line: Line = {
    <l:@L> "EOL" => Line::EndOfLine{line: l.line, index: l.index},
    <l:@L> <comment:Comment> <r:@R> "EOL" => Line::Comment{comment, line: l.line},
    <l:@L> <assignment:Assignment> <r:@R> "EOL" => {
      let e = lalrpop_util::ErrorRecovery { 
          error: lalrpop_util::ParseError::User {
              error: BehaviorParseError::new_unexpected_assignment(l, r)
          },
          dropped_tokens: vec![]
      };
      state.errors.push(e);
      Line::Assignment{assignment, line: l.line}
    },
    Initialize => <>,
    BehaviorBlock => <>,
    <block: Block> => {
      Line::UnknownBlock {
        unknown_block: block.0,
        line: block.1.line,
        range: TokenRange::new_line(block.1,block.2).expect(format!("Invalid token range while parsing `Block`: {:?} {:?}", block.1, block.2).as_str())
      }
    },
    SetBlock => <>,
    <l:@L> <variable:Variable> "EOL" => Line::Variable{variable, line: l.line},
    <l:@L> <error:!> <r:@R> => {
        state.errors.push(error); 
        Line::Error{start_line: l.line, end_line: r.line}
    },
}

Variable: tree::Variable = {
    <l:@L> <text:"EnvVariable"> <r:@R> => tree::Variable::Regular{text: text.into(), range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `EnvVariable`")},
    <l:@L> <text:"PartialEnvVariable"> <r:@R> => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: BehaviorParseError::new_missing_trailing('}', l, r)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        tree::Variable::Partial{text: text.into(), range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `PartialEnvVariable`")}
    },
}

Value: tree::Value = {
    <l:@L> <value:"bool"> <r:@R> => tree::Value::Boolean(value.0, value.1.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"int"> <r:@R> => tree::Value::Integer(value.0, value.1.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"float"> <r:@R> => tree::Value::Float(value.0, value.1.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"ValueString"> <r:@R> => tree::Value::String(value.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <quote: Quote> => quote.into(),
    <value: Variable> => value.into(),
}

VariableString: tree::VariableString = {
    <l:@L> <value:"ValueString"> <r:@R> => tree::VariableString::String(value.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    Variable => tree::VariableString::Variable(<>),
}

VariableStrings: tree::VariableStrings = {
    <variables: VariableString+> => variables.into()
}

Quote: tree::Quote = {
    <l:@L> QuoteBegin <content: Value*> QuoteEnd <r:@R> => tree::Quote{content: content.into(), range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Quote`")}
}

Comment: tree::Comment = {
    <l:@L> <text:"Comment"> <r:@R> => tree::Comment::new(text.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `Comment`")),
}

Keyword: tree::VariableString = {
  // TODO: This should preserve the case
  <l:@L> "initialize" <r:@R> => tree::VariableString::String("initialize".into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")).into(),
  <l:@L> "initialize_" <r:@R> => tree::VariableString::String("initialize_".into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")).into(),
  <l:@L> "Set" <r:@R> => tree::VariableString::String("set".into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")).into(),
  // NOTE: Behavior cannot be used because the parser cannot differentiate
  // between an assignment and a behavior block
  //<l:@L> "BehaviorBlock" <r:@R> => tree::VariableString::String("Behavior".into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")).into(),
}

Assignment: tree::Assignment = {
    <name:VariableStrings> "=" <value:Value*> <comment: Comment?> => tree::Assignment{name, value: value.into(), comment},
    // TODO: Need to handle keywords
    // This needs to handle variable strings
    <keyword: Keyword> "=" <value:Value*> <comment: Comment?> => tree::Assignment{name: keyword.into(), value: value.into(), comment},
}

Assignments: tree::Assignments = {
  <assignment: Assignment> => vec![assignment].into(),
  <mut assignments: Assignments> "," <assignment: Assignment> => {
    assignments.push(assignment);
    assignments
  },
}

Initialize: Line = {
    <l:@L> "initialize" <r:@R> <assignments: Assignments> "EOL" => Line::Initialize{assignments, deferred: false, line: l.line, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `initialize`")},
    <l:@L> "initialize_" <r:@R> <assignments: Assignments> "EOL" => Line::Initialize{assignments, deferred: true, line: l.line, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `initialize_`")},
}

CommentOrEmptyLine: Line = {
    <l:@L> "EOL" => Line::EndOfLine{line: l.line, index: l.index},
    <l:@L> <comment:Comment> <r:@R> "EOL" => Line::Comment{comment, line: l.line},
}

BehaviorBlockLine: Line = {
    <l:@L> "EOL" => Line::EndOfLine{line: l.line, index: l.index},
    <l:@L> <comment:Comment> <r:@R> "EOL" => Line::Comment{comment, line: l.line},
    <l:@L> <assignment:Assignment> "EOL" => Line::Assignment{assignment, line: l.line},
    Initialize => <>,
    <l:@L> <variable:Variable> "EOL" => Line::Variable{variable, line: l.line},
    <l:@L> <error:!> <r:@R> => {
        state.errors.push(error); 
        Line::Error{start_line: l.line, end_line: r.line}
    },
}

BehaviorBlock: Line = {
    <pl:@L> "BehaviorBlock" <pr:@R> "=" <behavior_name: VariableStrings> <behavior_block_comment: Comment?> "EOL" 
    <prelude_comments: CommentOrEmptyLine*>
    <block: Block>
        => Line::BehaviorBlock { 
            behavior_block: tree::BehaviorBlock {
                behavior_block_comment,
                behavior_name,
                prelude_comments: prelude_comments.into(),
                open_curly_line: block.0.open_curly_line,
                open_curly_index: block.0.open_curly_index,
                open_curly_comment: block.0.open_curly_comment,
                close_curly_line: block.0.close_curly_line,
                close_curly_index: block.0.close_curly_index,
                close_curly_comment: block.0.close_curly_comment,
                body: block.0.body,
            },
            line: pl.line,
            range: TokenRange::new_line(pl,pr).expect("Invalid token range while parsing `BehaviorBlock`")  
        },
}

Block: (tree::UnknownBlock, Location, Location) = {
    <ocl:@L> "{" <ocr:@R> <open_curly_comment: Comment?> "EOL"
    <body: BehaviorBlockLine*>
    <ccl:@L> "}" <close_curly_comment: Comment?> "EOL"
        => (
            tree::UnknownBlock {
                open_curly_line: ocl.line,
                open_curly_index: ocl.index,
                open_curly_comment,
                close_curly_line: ccl.line,
                close_curly_index: ccl.index,
                close_curly_comment,
                body: body.into(),
            },
            ocl, ocr
        ),
}

SetBlockLine: Line = {
    <l:@L> "EOL" => Line::EndOfLine{line: l.line, index: l.index},
    <l:@L> <comment:Comment> <r:@R> "EOL" => Line::Comment{comment, line: l.line},
    <l:@L> <assignment:Assignment> "EOL" => Line::Assignment{assignment, line: l.line},
    <l:@L> <variable:Variable> "EOL" => Line::Variable{variable, line: l.line},
    <l:@L> <error:!> <r:@R> => {
        state.errors.push(error); 
        Line::Error{start_line: l.line, end_line: r.line}
    },
}

SetBlock: Line = {
    <pl:@L> "Set" <pr:@R> <mode_variable_name: VariableStrings> "=" <mode_value: VariableStrings> 
    <set_block_comment: Comment?> "EOL"?
    <ocl:@L> "{" <open_curly_comment: Comment?> "EOL"
    <body: SetBlockLine*>
    <ccl:@L> "}" <else_value: VariableStrings?><close_curly_comment: Comment?> "EOL"
        => Line::SetBlock { 
            set_block: tree::SetBlock{
                set_block_comment: None,
                mode_variable_name,
                mode_value,
                prelude_comments: Vec::new().into(), // TODO: Need to add prelude_comments back in
                open_curly_line: ocl.line,
                open_curly_index: ocl.index,
                open_curly_comment,
                close_curly_line: ccl.line,
                close_curly_index: ccl.index,
                close_curly_comment,
                body: body.into(),
                else_value,
            },
            line: pl.line,
            range: TokenRange::new_line(pl,pr).expect("Invalid token range while parsing `SetBlock`")  
        },
}


// ---------------------------------------------------------------------------
// Token Definitions 
// ---------------------------------------------------------------------------

extern {  
    type Location = crate::lexers::Location;
    type Error = BehaviorParseError;
    
    enum Token<'input> {
        "Comment" => Token::Comment(<&'input str>),
        QuoteBegin => Token::QuoteBegin,
        QuoteEnd => Token::QuoteEnd,
        "ValueString" => Token::ValueString(<&'input str>),
        "EOL" => Token::EOL,
        "EnvVariable" => Token::EnvVariable(<&'input str>),
        "PartialEnvVariable" => Token::PartialEnvVariable(<&'input str>),
        "int" => Token::Integer(<i64>, <&'input str>),
        "float" => Token::Float(<f64>, <&'input str>),
        "bool" => Token::Boolean(<bool>, <&'input str>),
        "=" => Token::AssignmentOp,
        "initialize" => Token::InitializeKeyword,
        "initialize_" => Token::DeferredInitializeKeyword,
        "BehaviorBlock" => Token::BehaviorBlockKeyword,
        "Set" => Token::SetBlockKeyword,
        "{" => Token::CurlyOpen,
        "}" => Token::CurlyClose,
        "," => Token::Comma,
    }
}
