use std::str::FromStr;
use crate::lexers::{Location, TokenRange};
use crate::nsplug::error::PlugParseError;
use crate::nsplug::lexer::{State, Token};
use crate::nsplug::tree::{self, MacroDefinition, MacroCondition, MacroType, Line};
use lalrpop_util::ErrorRecovery;

//grammar<'input>(input: &'input str);
grammar<'s, 'input>(state: &'s mut State<'input>, input: &'input str);

pub Lines: Vec<Line<'input>> = <Line*>;

pub Line: Line<'input> = {
    MacroDefine => <>,
    MacroInclude => <>,
    //MacroElse => <>,
    //MacroEndif => <>,
    "EOL" => Line::EndOfLine,
    //<comment:"Comment"> => Line::Comment(comment),
    UnknownMacro => <>,
    <l:@L> <variable:Variable> => Line::Variable{variable, line: l.line},
    ! => { state.errors.push(<>); Line::Error },
}

// TODO: 
//   1. Add MacroIfDef
//   2. Add MacroElseIfDef
//   3. Add MacroIfNotDef


MacroDefine: Line<'input> = {
    <ml:@L> <d:"#define"> <mr:@R> <definition:MacroDefinition> <comment:"Comment"?> "EOL" => 
        Line::Macro{
            macro_type: MacroType::Define{definition, range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment, 
            line: ml.line,
        },
}

MacroDefinition: MacroDefinition<'input> = {
    <name:Value+> " " <value:Value*> => {
        MacroDefinition::new(name.into(), value.into())
    }
}

MacroElse: Line<'input> = {
    <ml:@L> <d:"#else"> <mr:@R> <l:@L> <extras:Value*> <r:@R> <comment:"Comment"?> "EOL" => {
        if !extras.is_empty() {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    // TODO: Need to create a more descriptive error
                    error: PlugParseError::new_missing_new_line(l, Location{line: r.line, index: r.index+1})
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Line::Error
        } else {
            Line::Macro{
                macro_type: MacroType::Else{range: TokenRange::new_line(ml,mr).unwrap()}, 
                comment,
                line: ml.line,
            }
        }
    },
}

MacroEndif: Line<'input> = {
    <ml:@L> <d:"#endif"> <mr:@R> <l:@L> <extras:Value*> <r:@R> <comment:"Comment"?> "EOL" => {
        if !extras.is_empty() {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    // TODO: Need to create a more descriptive error
                    error: PlugParseError::new_missing_new_line(l, Location{line: r.line, index: r.index+1})
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Line::Error
        } else {
            Line::Macro{
                macro_type: MacroType::EndIf{range: TokenRange::new_line(ml,mr).unwrap()}, 
                comment,
                line: ml.line,
            }
        }
    },
}

MacroInclude: Line<'input> = {
    <ml:@L> <d:"#include"> <mr:@R> <path:IncludePath> <l:@L> <comment:"Comment"?> <r:@R> "EOL" => {
        if let Some(comment) = comment {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: PlugParseError::new_unexpected_comment(comment, l, r)
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
        }
        Line::Macro{
            macro_type: MacroType::Include{path, range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment,
            line: ml.line,
        }
        
    }, 
    // TODO: Need to add support for `#include filename <tag>`
    
}

UnknownMacro: Line<'input> = {
     <l:@L> <m:"#unknown"> => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: PlugParseError::new_unknown_macro(l, m)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        Line::Error
    }
}

Variable: tree::Variable<'input> = {
    <l:@L> <text:"PlugVariable"> <r:@R> => tree::Variable::Regular{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")},
    <l:@L> <text:"PlugUpperVariable"> <r:@R> => tree::Variable::Upper{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")},
    <l:@L> <text:"PartialPlugVariable"> <r:@R> => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: PlugParseError::new_missing_trailing(')', l, r)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        tree::Variable::Partial{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")}
    },
    <l:@L> <text:"PartialPlugUpperVariable"> <r:@R> => tree::Variable::PartialUpper{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")},
}

Value: tree::Value<'input> = {
    <l:@L> <value:"bool"> <r:@R> => tree::Value::Boolean(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"int"> <r:@R> => tree::Value::Integer(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"float"> <r:@R> => tree::Value::Float(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"ValueString"> <r:@R> => tree::Value::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <quote: Quote> => quote.into(),
    <value: Variable> => value.into(),
}

VariableString: tree::VariableString<'input> = {
    <l:@L> <value:"ValueString"> <r:@R> => tree::VariableString::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    Variable => tree::VariableString::Variable(<>),
}

Quote: tree::Quote<'input> = {
    <l:@L> QuoteBegin <content: VariableString*> QuoteEnd <r:@R> => tree::Quote{content: content.into(), range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Quote`")}
}

IncludePath: tree::IncludePath<'input> = {
     <l:@L> <content: VariableString+> <r:@R> => tree::IncludePath::VariableStrings(content.into(), TokenRange::new_line(l,r).expect("Invalid token range while parsing `IncludePath`")),
    Quote => tree::IncludePath::Quote(<>),
}

// ---------------------------------------------------------------------------
// Token Definitions 
// ---------------------------------------------------------------------------

extern {  
    type Location = crate::lexers::Location;
    type Error = PlugParseError<'input>;
    
    enum Token<'input> {
        "Comment" => Token::Comment(<&'input str>),
        QuoteBegin => Token::QuoteBegin,
        QuoteEnd => Token::QuoteEnd,
        "ValueString" => Token::ValueString(<&'input str>),
        "EOL" => Token::EOL,
        "PlugVariable" => Token::PlugVariable(<&'input str>),
        "PartialPlugVariable" => Token::PartialPlugVariable(<&'input str>),
        "PlugUpperVariable" => Token::PlugUpperVariable(<&'input str>),
        "PartialPlugUpperVariable" => Token::PartialPlugUpperVariable(<&'input str>),
        "int" => Token::Integer(<i64>, <&'input str>),
        "float" => Token::Float(<f64>, <&'input str>),
        "bool" => Token::Boolean(<bool>, <&'input str>),
        "#define" => Token::MacroDefine,
        "#else" => Token::MacroElse,
        "#elseifdef" => Token::MacroElseIfDef,
        "#endif" => Token::MacroEndIf,
        "#ifdef" => Token::MacroIfDef,
        "#ifndef" => Token::MacroIfNotDef,
        "#include" => Token::MacroInclude,
        "#unknown" => Token::UnknownMacro(<&'input str>),
        "||" => Token::OrOperator,
        "&&" => Token::AndOperator,
        " " => Token::Space,
    }
}
