use std::str::FromStr;
use crate::lexers::{Location, TokenRange};
use crate::nsplug::error::PlugParseError;
use crate::nsplug::lexer::{State, Token};
use crate::nsplug::tree::{self, MacroDefinition, MacroCondition, MacroType, Line};
use lalrpop_util::ErrorRecovery;

//grammar<'input>(input: &'input str);
grammar<'s, 'input>(state: &'s mut State<'input>, input: &'input str);

pub Lines: tree::Lines<'input> = {
    <Line*> => <>.into()
}

pub Line: Line<'input> = {
    IfDef => <>,
    IfNotDef => <>,
    MacroDefine => <>,
    MacroInclude => <>,
    <l:@L> "EOL" => Line::EndOfLine{line: l.line, index: l.index},
    UnknownMacro => <>,
    <l:@L> <variable:Variable> => Line::Variable{variable, line: l.line},
    <l:@L> <error:!> <r:@R> => { 
        match &error.error {
            lalrpop_util::ParseError::UnrecognizedEOF { location, expected } => {
                if expected.contains(&"\"#endif\"".to_string()) {
                    let endl = if l.line < r.line {
                        Location::new(l.line + 1, 0)
                    } else {
                        r
                    };
                    let new_error = lalrpop_util::ErrorRecovery { 
                        error: lalrpop_util::ParseError::User {
                            error: PlugParseError::new_missing_endif(l, endl)
                        },
                        dropped_tokens: vec![]
                    };
                    state.errors.push(new_error);
                }
            }
            _ => {}
        }
        state.errors.push(error); 
        Line::Error{start_line: l.line, end_line: r.line}
    },
}

MacroDefine: Line<'input> = {
    <indent: WhiteSpace?> <ml:@L> <d:"#define"> <mr:@R> WhiteSpace+ <definition:MacroDefinition> <el:@L> "EOL" => 
        Line::Macro{
            macro_type: MacroType::Define{definition, range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment: None, 
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        },
}

MacroDefinition: MacroDefinition<'input> = {
    <name:VariableStrings> WhiteSpace+ <values:Values> WhiteSpace* => {
        MacroDefinition::new(name, values.into())
    },
    <name:VariableStrings> WhiteSpace* => {
        MacroDefinition::new(name, Vec::new().into())
    }
}

MacroInclude: Line<'input> = {
    <indent: WhiteSpace?> <ml:@L> <d:"#include"> <mr:@R>  WhiteSpace+ <pl:@L> <path:IncludeString> <pr:@R> WhiteSpace+ <tag: IncludeTag> <el:@L>"EOL" => {
        Line::Macro{
            macro_type: MacroType::Include{
                path: tree::IncludePath::VariableStrings(path, TokenRange::new_line(pl,pr).expect("Invalid token range while parsing `IncludePath`")),
                tag: Some(tag),
                range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment: None,
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        }
    },
    <indent: WhiteSpace?> <ml:@L> <d:"#include"> <mr:@R>  WhiteSpace+ <pl:@L> <path:IncludeString> <pr:@R> WhiteSpace* <el:@L>"EOL" => {
        Line::Macro{
            macro_type: MacroType::Include{
                path: tree::IncludePath::VariableStrings(path, TokenRange::new_line(pl,pr).expect("Invalid token range while parsing `IncludePath`")),
                tag: None,
                range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment: None,
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        }
    },
    // Quote
    <indent: WhiteSpace?> <ml:@L> <d:"#include"> <mr:@R>  WhiteSpace+ <pl:@L> <path:Quote> <pr:@R> WhiteSpace+ <tag: IncludeTag> <el:@L>"EOL" => {
        Line::Macro{
            macro_type: MacroType::Include{
                path: tree::IncludePath::Quote(path),
                tag: Some(tag),
                range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment: None,
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        }
    },
    <indent: WhiteSpace?> <ml:@L> <d:"#include"> <mr:@R>  WhiteSpace+ <pl:@L> <path:Quote> <pr:@R> WhiteSpace* <el:@L>"EOL" => {
        Line::Macro{
            macro_type: MacroType::Include{
                path: tree::IncludePath::Quote(path),
                tag: None,
                range: TokenRange::new_line(ml,mr).unwrap()}, 
            comment: None,
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        }
    },
}

UnknownMacro: Line<'input> = {
     <indent: WhiteSpace?> <l:@L> <m:"#unknown"> <r:@R> DropTokens* "EOL" => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: PlugParseError::new_unknown_macro(l, m)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        Line::Error{start_line: l.line, end_line: r.line}
    }
}

Variable: tree::Variable<'input> = {
    <l:@L> <text:"PlugVariable"> <r:@R> => tree::Variable::Regular{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `PlugVariable`")},
    <l:@L> <text:"PlugUpperVariable"> <r:@R> => tree::Variable::Upper{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `PlugUpperVariable`")},
    <l:@L> <text:"PartialPlugVariable"> <r:@R> => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: PlugParseError::new_missing_trailing(')', l, r)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        tree::Variable::Partial{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `PartialPlugVariable`")}
    },
    <l:@L> <text:"PartialPlugUpperVariable"> <r:@R> => {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: PlugParseError::new_missing_trailing(')', l, r)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        tree::Variable::PartialUpper{text, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `PartialPlugUpperVariable`")}
    },
}

Value: tree::Value<'input> = {
    <l:@L> <value:"bool"> <r:@R> => tree::Value::Boolean(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"int"> <r:@R> => tree::Value::Integer(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"float"> <r:@R> => tree::Value::Float(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"ValueString"> <r:@R> => tree::Value::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <quote: Quote> => quote.into(),
    <value: Variable> => value.into(),
}

DropTokens: () = {
    "&&" => {},
    "||" => {},
    <value: Value> => {},
    <WhiteSpace> => {},
}

Values: tree::Values<'input> = {
    <values:Value+> => values.into(),
    <mut lhs:Values> <l:@L> <ws: WhiteSpace+> <r:@R> <rhs:Value+> => {
        for w in ws {
            lhs.push(tree::Value::String(w, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")));
        }
        lhs.extend(rhs);
        lhs.into()
    },
}

VariableString: tree::VariableString<'input> = {
    <l:@L> <value:"bool"> <r:@R> => tree::VariableString::String(value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    <l:@L> <value:"int"> <r:@R> => tree::VariableString::String(value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    <l:@L> <value:"float"> <r:@R> => tree::VariableString::String(value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    <l:@L> <value:"ValueString"> <r:@R> => tree::VariableString::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `VariableString`")),
    Variable => tree::VariableString::Variable(<>),
}

VariableStrings: tree::VariableStrings<'input> = {
    <variables: VariableString+> => variables.into()
}

IncludeString: tree::VariableStrings<'input> = {    
    <variables: VariableString+> => variables.into(),
    <mut lhs:IncludeString> <l:@L> <ws: WhiteSpace+> <r:@R> <rhs: VariableString+> => {
        for w in ws {
            lhs.push(tree::VariableString::String(w, TokenRange::new_line(l,r).expect("Invalid token range while parsing `IncludeString`")));
        }
        lhs.extend(rhs);
        lhs
    },
}

Quote: tree::Quote<'input> = {
    <l:@L> QuoteBegin <content: Value*> QuoteEnd <r:@R> => tree::Quote{content: content.into(), range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `Quote`")}
}

IncludePath: tree::IncludePath<'input> = {
    <l:@L> <content: IncludeString> <r:@R> => tree::IncludePath::VariableStrings(content, TokenRange::new_line(l,r).expect("Invalid token range while parsing `IncludePath`")),
    <quote: Quote> => tree::IncludePath::Quote(quote),
}

IncludeTag: tree::IncludeTag<'input> = {
    <l:@L> "<" <tag: "ValueString"> ">" <r:@R> => tree::IncludeTag{tag, range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `IncludeTag`")},
}

IfDef: Line<'input> = {
    <indent: WhiteSpace?> <ml:@L> "#ifdef" <mr:@R> WhiteSpace+ <condition:MacroCondition> <el:@L> "EOL" <body:Line+?> <branch: IfDefBranch> => 
        Line::Macro{
            macro_type: MacroType::IfDef{
                condition,
                branch,
                body: body.unwrap_or_default().into(),
                range: TokenRange::new_line(ml,mr).unwrap(),
                }, 
            comment: None, 
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        },
}

IfDefBranch: tree::IfDefBranch<'input> = {
    <indent: WhiteSpace?> <ml:@L> "#elseifdef" <mr:@R> WhiteSpace+ <condition:MacroCondition> <el:@L> "EOL" <body:Line+?> <branch: IfDefBranch> => 
        tree::IfDefBranch::ElseIfDef {
            line: ml.line,
            line_end_index: el.index,
            macro_range: TokenRange::new_line(ml,mr).unwrap(),
            indent: indent.unwrap_or_default(),
            condition,
            body: body.unwrap_or_default().into(),
            branch: Box::new(branch),
        },
    <indent: WhiteSpace?> <ml:@L> "#else" <mr:@R> WhiteSpace* <el:@L> "EOL" <body:Line+?> <endif_indent: WhiteSpace?> <endl:@L> "#endif" <endr:@R> WhiteSpace* <eel:@L> "EOL" => 
        tree::IfDefBranch::Else {
            line: ml.line,
            line_end_index: el.index,
            macro_range: TokenRange::new_line(ml,mr).unwrap(),
            indent: indent.unwrap_or_default(),
            body: body.unwrap_or_default().into(),
            endif_line: endl.line,
            endif_line_end_index: eel.index,
            endif_macro_range: TokenRange::new_line(endl,endr).unwrap(),
            endif_indent: endif_indent.unwrap_or_default(),
        },
    <indent: WhiteSpace?> <ml:@L> "#endif" <mr:@R> WhiteSpace* <el:@L> "EOL" => 
        tree::IfDefBranch::EndIf {
            line: ml.line,
            line_end_index: el.index,
            macro_range: TokenRange::new_line(ml,mr).unwrap(),
            indent: indent.unwrap_or_default(),
        },
}

MacroCondition: tree::MacroCondition<'input> = {
    MacroDefinition => tree::MacroCondition::Simple(<>),
    <lhs: MacroDefinition> <l:@L> "||" WhiteSpace* <r:@R> <rhs: MacroCondition> => 
        tree::MacroCondition::Disjunction{
            operator_range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `MacroCondition`"),
            lhs,
            rhs: Box::new(rhs),
        },
    <lhs: MacroDefinition> <l:@L> "&&" WhiteSpace* <r:@R> <rhs: MacroCondition> => 
        tree::MacroCondition::Conjunction{
            operator_range: TokenRange::new_line(l,r).expect("Invalid token range while parsing `MacroCondition`"),
            lhs,
            rhs: Box::new(rhs),
        },
}

IfNotDef: Line<'input> = {
    <indent: WhiteSpace?> <ml:@L> "#ifndef" <mr:@R> WhiteSpace+ <clauses:IfNotDefClauses> WhiteSpace* <el:@L> "EOL" <body:Line+?> <branch: IfNotDefBranch> => 
        Line::Macro{
            macro_type: MacroType::IfNotDef{
                clauses,
                branch,
                body: body.unwrap_or_default().into(),
                range: TokenRange::new_line(ml,mr).unwrap(),
                }, 
            comment: None, 
            line: ml.line,
            line_end_index: el.index,
            indent: indent.unwrap_or_default(),
        },
}

IfNotDefBranch: tree::IfNotDefBranch<'input> = {
    <indent: WhiteSpace?> <ml:@L> "#else" <mr:@R> WhiteSpace* <el:@L> "EOL" <body:Line+?> <endif_indent: WhiteSpace?> <endl:@L> "#endif" <endr:@R> WhiteSpace* <eel:@L> "EOL" => 
        tree::IfNotDefBranch::Else {
            line: ml.line,
            line_end_index: el.index,
            macro_range: TokenRange::new_line(ml,mr).unwrap(),
            indent: indent.unwrap_or_default(),
            body: body.unwrap_or_default().into(),
            endif_line: endl.line,
            endif_line_end_index: eel.index,
            endif_macro_range: TokenRange::new_line(endl,endr).unwrap(),
            endif_indent: endif_indent.unwrap_or_default(),
        },
    <indent: WhiteSpace?> <ml:@L> "#endif" <mr:@R> WhiteSpace* <el:@L> "EOL" => 
        tree::IfNotDefBranch::EndIf {
            line: ml.line,
            line_end_index: el.index,
            macro_range: TokenRange::new_line(ml,mr).unwrap(),
            indent: indent.unwrap_or_default(),
        },
}

IfNotDefClauses: tree::IfNotDefClauses<'input> = {
    <clause: VariableStrings> => clause.into(),
    <mut clauses: IfNotDefClauses> WhiteSpace+ <clause: VariableStrings> => {
        clauses.push(clause.into()); 
        clauses
    },
}


// ---------------------------------------------------------------------------
// Token Definitions 
// ---------------------------------------------------------------------------

extern {  
    type Location = crate::lexers::Location;
    type Error = PlugParseError<'input>;
    
    enum Token<'input> {
        QuoteBegin => Token::QuoteBegin,
        QuoteEnd => Token::QuoteEnd,
        "ValueString" => Token::ValueString(<&'input str>),
        "EOL" => Token::EOL,
        "PlugVariable" => Token::PlugVariable(<&'input str>),
        "PartialPlugVariable" => Token::PartialPlugVariable(<&'input str>),
        "PlugUpperVariable" => Token::PlugUpperVariable(<&'input str>),
        "PartialPlugUpperVariable" => Token::PartialPlugUpperVariable(<&'input str>),
        "int" => Token::Integer(<i64>, <&'input str>),
        "float" => Token::Float(<f64>, <&'input str>),
        "bool" => Token::Boolean(<bool>, <&'input str>),
        "#define" => Token::MacroDefine,
        "#else" => Token::MacroElse,
        "#elseifdef" => Token::MacroElseIfDef,
        "#endif" => Token::MacroEndIf,
        "#ifdef" => Token::MacroIfDef,
        "#ifndef" => Token::MacroIfNotDef,
        "#include" => Token::MacroInclude,
        "#unknown" => Token::UnknownMacro(<&'input str>),
        "||" => Token::OrOperator,
        "&&" => Token::AndOperator,
        "<" => Token::LeftAngleBracket,
        ">" => Token::RightAngleBracket,
        WhiteSpace => Token::WhiteSpace(<&'input str>),
    }
}
