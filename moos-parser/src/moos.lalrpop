use std::str::FromStr;
use crate::helpers::remove_first_last;
use crate::lexers::{Location, TokenRange};
use crate::lexer::{State, Token};
use crate::parser::{MacroDefinition, MacroCondition, MacroType, Line};
use crate::error::MoosParseError;
use lalrpop_util::ErrorRecovery;

//grammar<'input>(input: &'input str);
grammar<'s, 'input>(state: &'s mut State<'input>, input: &'input str);

pub Lines: Vec<Line<'input>> = <Line*>;

pub Line: Line<'input> = {
    Define => <>,
    MacroDefine => <>,
    MacroInclude => <>,
    MacroElse => <>,
    MacroEndif => <>,
    BlockBegin => <>,
    BlockEnd => <>,
    Assignment => <>,
    // TODO: Add a catch-all for unknown lines
    "EOL" => Line::EndOfLine,
    <comment:"Comment"> => Line::Comment(comment),
    UnknownMacro => <>,
    ! => { state.errors.push(<>); Line::Error },
    
}

// ---------------------------------------------------------------------------
// Basic Lines 
// ---------------------------------------------------------------------------

BlockBegin: Line<'input> = {
    "BlockKeyword" "=" <name:"ValueString"> <comment:"Comment"?> <eol:"EOL"?> <l:@L> "{" <r:@R> =>? match eol {
        //None => Err(lalrpop_util::ParseError::User {
        //    error: MoosParseError::new_missing_new_line(l, r)
        //}),
        None => {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: MoosParseError::new_missing_new_line(l, r)
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Ok(Line::Error)
        }
        Some(_) => Ok(Line::BlockBegin(name, comment)),
    },
}

BlockEnd: Line<'input> = {
    "}" <comment:"Comment"?> "EOL" => Line::BlockEnd(comment),
}

Define: Line<'input> = {
    <d:"Define"> <name:"ValueString"> "=" <value:Value> <comment:"Comment"?> "EOL" => {
        state.defines.insert(name.to_owned(), value.to_string());
        Line::Define(name, value, comment)
    }
}

// TODO: I'm not sure we should be parsing variables like this here...
// It might be easier to treat everything as a string, and handle variables
// later. Technically, variables could be anything. E.G.
// export TEST="TEST=1234"
Assignment: Line<'input> = {
    <key:Value+> "=" <value:Value+> <comment:"Comment"?> "EOL" => Line::Assignment(key,value, comment),
}

// TODO: The original MOOS parser treated everything after the equal sign as
// the value. It also allowed for anything before the equal to be the key..
// Should we match the original implementation or write something that
// applies stricter rules. E.G. keys must be an identifier: [a-zA-Z0-9_-.]+
Value: crate::parser::Value<'input> = {
    <l:@L> <value:"bool"> <r:@R> => crate::parser::Value::Boolean(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"int"> <r:@R> => crate::parser::Value::Integer(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"float"> <r:@R> => crate::parser::Value::Float(value.0, value.1, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"ValueString"> <r:@R> => crate::parser::Value::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"Quote"> <r:@R> => crate::parser::Value::String(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"PlugVariable"> <r:@R> => crate::parser::Value::PlugVariable(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"PlugUpperVariable"> <r:@R> => crate::parser::Value::PlugUpperVariable(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"PartialPlugVariable"> <r:@R> => crate::parser::Value::PartialPlugVariable(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"PartialPlugUpperVariable"> <r:@R> => crate::parser::Value::PartialPlugUpperVariable(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"EnvVariable"> <r:@R> => crate::parser::Value::EnvVariable(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
    <l:@L> <value:"PartialEnvVariable"> <r:@R> => crate::parser::Value::PartialEnvVariable(value, TokenRange::new_line(l,r).expect("Invalid token range while parsing `Value`")),
}

// ---------------------------------------------------------------------------
// Macros 
// ---------------------------------------------------------------------------

// TODO: 
//   1. Add MacroIfDef
//   2. Add MacroElseIfDef
//   3. Add MacroIfNotDef


MacroDefinition: MacroDefinition<'input> = {
    <name:"ValueString"> <value:Value?> => {
        MacroDefinition::new(name, value)
    }
}

MacroDefine: Line<'input> = {
    <d:"define"> <def:MacroDefinition> <comment:"Comment"?> "EOL" => Line::Macro(MacroType::Define(def), comment),
}


MacroElse: Line<'input> = {
    <d:"else"> <l:@L> <extras:Value*> <r:@R> <comment:"Comment"?> "EOL" => {
        if !extras.is_empty() {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    // TODO: Need to create a more descriptive error
                    error: MoosParseError::new_missing_new_line(l, Location{line: r.line, index: r.index+1})
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Line::Error
        } else {
            Line::Macro(MacroType::Else, comment)
        }
    },
}

MacroEndif: Line<'input> = {
    <d:"endif"> <l:@L> <extras:Value*> <r:@R> <comment:"Comment"?> "EOL" => {
        if !extras.is_empty() {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    // TODO: Need to create a more descriptive error
                    error: MoosParseError::new_missing_new_line(l, Location{line: r.line, index: r.index+1})
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Line::Error
        } else {
            Line::Macro(MacroType::EndIf, comment)
        }
    },
}

MacroInclude: Line<'input> = {
    <d:"include"> <path:"ValueString"> <l:@L> <extras:Value*> <r:@R> <comment:"Comment"?> "EOL" => {
        if !extras.is_empty() {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    // TODO: Need to create a more descriptive error
                    error: MoosParseError::new_missing_new_line(l, Location{line: r.line, index: r.index+1})
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Line::Error
        } else {
            Line::Macro(MacroType::Include(path), comment)
        }
    }, 
    <d:"include"> <path:"Quote"> <l:@L> <extras:Value*> <r:@R> <comment:"Comment"?> "EOL" => {
        if !extras.is_empty() {
            let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    // TODO: Need to create a more descriptive error
                    error: MoosParseError::new_missing_new_line(l, Location{line: r.line, index: r.index+1})
                },
                dropped_tokens: vec![]
            };
            state.errors.push(e);
            Line::Error
        } else {
            Line::Macro(MacroType::Include(path), comment)
        }
    }, 
}

UnknownMacro: Line<'input> = {
     <l:@L> <m:"unknown_macro"> => {
        let e = lalrpop_util::ErrorRecovery { 
                error: lalrpop_util::ParseError::User {
                    error: MoosParseError::new_unknown_macro(l, m)
                },
                dropped_tokens: vec![]
            };
        state.errors.push(e);
        Line::Error
    }
}



// ---------------------------------------------------------------------------
// Token Definitions 
// ---------------------------------------------------------------------------

extern {  
    type Location = crate::lexers::Location;
    type Error = MoosParseError<'input>;
    
    enum Token<'input> {
        "(" => Token::ParenOpen, 
        ")" => Token::ParenClose, 
        "=" => Token::AssignOp,
        "Comment" => Token::Comment(<&'input str>),
        "Quote" => Token::Quote(<&'input str>),
        "PartialQuote" => Token::PartialQuote(<&'input str>, <char>),
        "Define" => Token::DefineKeyword,
        "BlockKeyword" => Token::BlockKeyword(<&'input str>),
        "Key" => Token::Key(<&'input str>),
        "ValueString" => Token::ValueString(<&'input str>),
        "EOL" => Token::EOL,
        "EnvVariable" => Token::EnvVariable(<&'input str>),
        "PartialEnvVariable" => Token::PartialEnvVariable(<&'input str>),
        "PlugVariable" => Token::PlugVariable(<&'input str>),
        "PartialPlugVariable" => Token::PartialPlugVariable(<&'input str>),
        "PlugUpperVariable" => Token::PlugUpperVariable(<&'input str>),
        "PartialPlugUpperVariable" => Token::PartialPlugUpperVariable(<&'input str>),
        "{" => Token::CurlyOpen,
        "}" => Token::CurlyClose,
        "int" => Token::Integer(<i64>, <&'input str>),
        "float" => Token::Float(<f64>, <&'input str>),
        "bool" => Token::Boolean(<bool>, <&'input str>),
        "define" => Token::MacroDefine,
        "else" => Token::MacroElse,
        "elseifdef" => Token::MacroElseIfDef,
        "endif" => Token::MacroEndIf,
        "ifdef" => Token::MacroIfDef,
        "ifndef" => Token::MacroIfNotDef,
        "include" => Token::MacroInclude,
        "unknown_macro" => Token::UnknownMacro(<&'input str>),
        "||" => Token::OrOperator,
        "&&" => Token::AndOperator,
    }
}
